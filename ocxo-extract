#!/usr/bin/env bash
# ocxo-extract - Extract text and metadata from ocxo JSON output
# Usage: ocxo run --command <cmd> --format json | ocxo-extract <subcommand>

set -euo pipefail

show_usage() {
  cat <<'EOF'
Usage: ocxo run --command <cmd> --format json | ocxo-extract [subcommand]

Subcommands:
  final-text        Extract text where type == step_finish and messageID is matching (default)
  last-text         Extract last text when type == "text"
  before-finish     Extract text just above type == step_finish
  tools             Show tool usage summary (tools called, files read, commands run)
   
Options:
  --no-session      Don't output session ID (text only)
  --no-duration     Don't output duration
  --json            Output tools as JSON (for tools subcommand)
  -h, --help        Show this help message

Examples:
  ocxo run --command se_infra --format json | ocxo-extract
  ocxo run --command se_infra --format json | ocxo-extract final-text --no-session
  ocxo run --command se_infra --format json | ocxo-extract tools
EOF
}

is_valid_json() {
  echo "$1" | jq -e . >/dev/null 2>&1
}

extract_error() {
  local json="$1"
  echo "$json" | jq -r '
    if .error then
      "Error: " + (.error.name // "Unknown") + 
      "\nMessage: " + (.error.data.message // "No message") +
      "\nStatus: " + ((.error.data.statusCode // "N/A") | tostring)
    else
      "Error: Unknown error format"
    end
  ' 2>/dev/null || echo "Error: Failed to parse error response"
}

format_duration() {
  local ms="$1"
  local seconds=$((ms / 1000))
  local minutes=$((seconds / 60))
  local hours=$((minutes / 60))
  
  if [[ $hours -gt 0 ]]; then
    echo "${hours}h $((minutes % 60))m $((seconds % 60))s"
  elif [[ $minutes -gt 0 ]]; then
    echo "${minutes}m $((seconds % 60))s"
  elif [[ $seconds -gt 0 ]]; then
    echo "${seconds}s"
  else
    echo "${ms}ms"
  fi
}

SHOW_SESSION=true
SHOW_DURATION=true
OUTPUT_JSON=false
SUBCOMMAND=""

while [[ $# -gt 0 ]]; do
  case $1 in
    --no-session)
      SHOW_SESSION=false
      shift
      ;;
    --no-duration)
      SHOW_DURATION=false
      shift
      ;;
    --json)
      OUTPUT_JSON=true
      shift
      ;;
    -h|--help)
      show_usage
      exit 0
      ;;
    *)
      if [[ -z "$SUBCOMMAND" ]]; then
        SUBCOMMAND="$1"
      else
        echo "Error: Unknown argument: $1" >&2
        show_usage >&2
        exit 1
      fi
      shift
      ;;
  esac
done

if [[ -z "$SUBCOMMAND" ]]; then
  SUBCOMMAND="final-text"
fi

RAW_INPUT=$(cat)

if [[ -z "$RAW_INPUT" ]]; then
  echo "Error: No input provided" >&2
  exit 1
fi

JSON_LINES=""
NON_JSON_LINES=""
while IFS= read -r line; do
  if [[ -z "$line" ]]; then
    continue
  fi
  if is_valid_json "$line"; then
    JSON_LINES="${JSON_LINES}${line}"$'\n'
  else
    NON_JSON_LINES="${NON_JSON_LINES}${line}"$'\n'
  fi
done <<< "$RAW_INPUT"

if [[ -z "$JSON_LINES" ]]; then
  echo "Error: No valid JSON found in input" >&2
  if [[ -n "$NON_JSON_LINES" ]]; then
    echo "Non-JSON output:" >&2
    echo "$NON_JSON_LINES" >&2
  fi
  exit 1
fi

FIRST_JSON=$(echo "$JSON_LINES" | head -1)
if echo "$FIRST_JSON" | jq -e '.type == "error"' >/dev/null 2>&1; then
  if [[ "$SHOW_SESSION" == "true" ]]; then
    SESSION_ID=$(echo "$FIRST_JSON" | jq -r '.sessionID // "N/A"')
    echo "Session: $SESSION_ID"
    echo "---"
  fi
  extract_error "$FIRST_JSON"
  exit 1
fi

SESSION_ID=$(echo "$JSON_LINES" | jq -r 'select(.sessionID != null) | .sessionID' | head -1)

DURATION_MS=$(echo "$JSON_LINES" | jq -rs '
  [.[] | select(.timestamp != null) | .timestamp] |
  if length > 0 then (last - first) else 0 end
')

case "$SUBCOMMAND" in
  last-text)
    TEXT=$(echo "$JSON_LINES" | jq -rs '
      [.[] | select(.type == "text")] | 
      if length > 0 then last.part.text else null end
    ')
    ;;
    
  before-finish)
    TEXT=$(echo "$JSON_LINES" | jq -rs '
      [.[]] as $all |
      last($all[] | select(.type == "step_finish")) as $last_finish |
      if $last_finish then
        [$all[] | select(.type == "text" and .part.messageID == $last_finish.part.messageID)] |
        if length > 0 then last.part.text else null end
      else
        null
      end
    ')
    ;;
    
  final-text)
    TEXT=$(echo "$JSON_LINES" | jq -rs '
      [.[]] |
      group_by(.part.messageID) | 
      map(select(any(.[]; .type == "step_finish"))) |
      if length > 0 then
        last | 
        [.[] | select(.type == "text")] | 
        if length > 0 then last.part.text else null end
      else
        null
      end
    ')
    ;;
    
  tools)
    TOOLS_DATA=$(echo "$JSON_LINES" | jq -rs '
      [.[] | select(.type == "tool_use")] |
      {
        tools: [.[] | .part.toolName] | unique,
        files_read: [.[] | select(.part.toolName == "read") | .part.input.filePath // .part.input.file_path // empty],
        files_written: [.[] | select(.part.toolName == "write" or .part.toolName == "edit") | .part.input.filePath // .part.input.file_path // empty],
        commands: [.[] | select(.part.toolName == "bash") | .part.input.command // empty],
        total_calls: length,
        by_tool: [.[] | .part.toolName] | group_by(.) | map({name: .[0], count: length})
      }
    ')
    
    if [[ "$OUTPUT_JSON" == "true" ]]; then
      echo "$TOOLS_DATA"
    else
      if [[ "$SHOW_SESSION" == "true" && -n "$SESSION_ID" && "$SESSION_ID" != "null" ]]; then
        echo "Session: $SESSION_ID"
      fi
      if [[ "$SHOW_DURATION" == "true" && "$DURATION_MS" -gt 0 ]]; then
        echo "Duration: $(format_duration "$DURATION_MS")"
      fi
      if [[ "$SHOW_SESSION" == "true" || "$SHOW_DURATION" == "true" ]]; then
        echo "---"
      fi
      echo "$TOOLS_DATA" | jq -r '
        "Tools Used: " + (.tools | join(", ")),
        "",
        "Total Tool Calls: " + (.total_calls | tostring),
        "",
        "Calls by Tool:",
        (.by_tool[] | "  \(.name): \(.count)"),
        "",
        "Files Read:",
        (if (.files_read | length) > 0 then .files_read[] | "  \(.)" else "  (none)" end),
        "",
        "Files Written/Edited:",
        (if (.files_written | length) > 0 then .files_written[] | "  \(.)" else "  (none)" end),
        "",
        "Commands Run:",
        (if (.commands | length) > 0 then .commands[] | "  \(.)" else "  (none)" end)
      '
    fi
    exit 0
    ;;
    
  *)
    echo "Error: Unknown subcommand: $SUBCOMMAND" >&2
    show_usage >&2
    exit 1
    ;;
esac

if [[ "$TEXT" == "null" || -z "$TEXT" ]]; then
  echo "Error: No text content found for subcommand '$SUBCOMMAND'" >&2
  exit 1
fi

if [[ "$SHOW_SESSION" == "true" && -n "$SESSION_ID" && "$SESSION_ID" != "null" ]]; then
  echo "Session: $SESSION_ID"
fi
if [[ "$SHOW_DURATION" == "true" && "$DURATION_MS" -gt 0 ]]; then
  echo "Duration: $(format_duration "$DURATION_MS")"
fi
if [[ "$SHOW_SESSION" == "true" || "$SHOW_DURATION" == "true" ]]; then
  echo "---"
fi

echo "$TEXT"
